import { ChangeDetectionStrategy, ChangeDetectorRef, Input, ViewChildren } from '@angular/core';
import { Component } from '@angular/core';
import { Subject } from 'rxjs';
import { filter } from 'rxjs/operators';
import { HotToastComponent } from '../hot-toast/hot-toast.component';
import { HOT_TOAST_MARGIN } from '../../constants';
export class HotToastContainerComponent {
    constructor(cdr) {
        this.cdr = cdr;
        this.toasts = [];
        this.toastRefs = [];
        /** Subject for notifying the user that the toast has been closed. */
        this._onClosed = new Subject();
        this.onClosed$ = this._onClosed.asObservable();
    }
    trackById(index, toast) {
        return toast.id;
    }
    calculateOffset(toastId, position) {
        const visibleToasts = this.toasts.filter((t) => t.visible && t.position === position);
        const index = visibleToasts.findIndex((toast) => toast.id === toastId);
        const offset = index !== -1
            ? visibleToasts
                .slice(...(this.defaultConfig.reverseOrder ? [index + 1] : [0, index]))
                .reduce((acc, t) => acc + (t.height || 0) + HOT_TOAST_MARGIN, 0)
            : 0;
        return offset;
    }
    updateHeight(height, toast) {
        toast.height = height;
        this.cdr.detectChanges();
    }
    addToast(ref) {
        this.toastRefs.push(ref);
        const toast = ref.getToast();
        this.toasts.push(ref.getToast());
        this.cdr.detectChanges();
        return {
            dispose: () => {
                this.closeToast(toast.id);
            },
            updateMessage: (message) => {
                toast.message = message;
                this.cdr.detectChanges();
            },
            updateToast: (options) => {
                this.updateToasts(toast, options);
                this.cdr.detectChanges();
            },
            afterClosed: this.getAfterClosed(toast),
        };
    }
    closeToast(id) {
        const comp = this.hotToastComponentList.find((item) => item.toast.id === id);
        if (comp) {
            comp.close();
        }
    }
    beforeClosed(toast) {
        toast.visible = false;
    }
    afterClosed(closeToast) {
        const toastIndex = this.toasts.findIndex((t) => t.id === closeToast.id);
        if (toastIndex > -1) {
            this._onClosed.next(closeToast);
            this.toasts = this.toasts.filter((t) => t.id !== closeToast.id);
            this.toastRefs = this.toastRefs.filter((t) => t.getToast().id !== closeToast.id);
            this.cdr.detectChanges();
        }
    }
    hasToast(id) {
        return this.toasts.findIndex((t) => t.id === id) > -1;
    }
    getAfterClosed(toast) {
        return this.onClosed$.pipe(filter((v) => v.id === toast.id));
    }
    updateToasts(toast, options) {
        this.toasts = this.toasts.map((t) => (Object.assign(Object.assign({}, t), (t.id === toast.id && Object.assign(Object.assign({}, toast), options)))));
    }
}
HotToastContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'hot-toast-container',
                template: "<div style=\"position: fixed; z-index: 9999; top: 0; right: 0; bottom: 0; left: 0; pointer-events: none\">\n  <div style=\"position: relative; height: 100%\">\n    <hot-toast\n      *ngFor=\"let toast of toasts; trackBy: trackById; let i = index\"\n      [toast]=\"toast\"\n      [offset]=\"calculateOffset(toast.id, toast.position)\"\n      [toastRef]=\"toastRefs[i]\"\n      (height)=\"updateHeight($event, toast)\"\n      (beforeClosed)=\"beforeClosed(toast)\"\n      (afterClosed)=\"afterClosed($event)\"\n    ></hot-toast>\n  </div>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush
            },] }
];
HotToastContainerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
HotToastContainerComponent.propDecorators = {
    defaultConfig: [{ type: Input }],
    hotToastComponentList: [{ type: ViewChildren, args: [HotToastComponent,] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG90LXRvYXN0LWNvbnRhaW5lci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmduZWF0L2hvdC10b2FzdC9zcmMvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy9ob3QtdG9hc3QtY29udGFpbmVyL2hvdC10b2FzdC1jb250YWluZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxpQkFBaUIsRUFBRSxLQUFLLEVBQWEsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNHLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDMUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQVcvQixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFeEMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDckUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFPbkQsTUFBTSxPQUFPLDBCQUEwQjtJQWFyQyxZQUFvQixHQUFzQjtRQUF0QixRQUFHLEdBQUgsR0FBRyxDQUFtQjtRQVIxQyxXQUFNLEdBQVksRUFBRSxDQUFDO1FBQ3JCLGNBQVMsR0FBd0IsRUFBRSxDQUFDO1FBRXBDLHFFQUFxRTtRQUM3RCxjQUFTLEdBQUcsSUFBSSxPQUFPLEVBQWlCLENBQUM7UUFFekMsY0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxFQUFFLENBQUM7SUFFTCxDQUFDO0lBRTlDLFNBQVMsQ0FBQyxLQUFhLEVBQUUsS0FBWTtRQUNuQyxPQUFPLEtBQUssQ0FBQyxFQUFFLENBQUM7SUFDbEIsQ0FBQztJQUVELGVBQWUsQ0FBQyxPQUFlLEVBQUUsUUFBdUI7UUFDdEQsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxD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QVMsU0FBQztnQkFDVCxRQUFRLEVBQUUscUJBQXFCO2dCQUMvQiwraUJBQW1EO2dCQUNuRCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTthQUNoRDs7O1lBdEJpQyxpQkFBaUI7Ozs0QkF3QmhELEtBQUs7b0NBRUwsWUFBWSxTQUFDLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgSW5wdXQsIFF1ZXJ5TGlzdCwgVmlld0NoaWxkcmVuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIEhvdFRvYXN0Q2xvc2UsXG4gIFRvYXN0LFxuICBUb2FzdENvbmZpZyxcbiAgVG9hc3RQb3NpdGlvbixcbiAgVXBkYXRlVG9hc3RPcHRpb25zLFxuICBBZGRUb2FzdFJlZixcbiAgQ3JlYXRlSG90VG9hc3RSZWYsXG59IGZyb20gJy4uLy4uL2hvdC10b2FzdC5tb2RlbCc7XG5pbXBvcnQgeyBIb3RUb2FzdFJlZiB9IGZyb20gJy4uLy4uL2hvdC10b2FzdC1yZWYnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQ29udGVudCB9IGZyb20gJ0BuZ25lYXQvb3ZlcnZpZXcnO1xuaW1wb3J0IHsgSG90VG9hc3RDb21wb25lbnQgfSBmcm9tICcuLi9ob3QtdG9hc3QvaG90LXRvYXN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBIT1RfVE9BU1RfTUFSR0lOIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnaG90LXRvYXN0LWNvbnRhaW5lcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9ob3QtdG9hc3QtY29udGFpbmVyLmNvbXBvbmVudC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIEhvdFRvYXN0Q29udGFpbmVyQ29tcG9uZW50IHtcbiAgQElucHV0KCkgZGVmYXVsdENvbmZpZzogVG9hc3RDb25maWc7XG5cbiAgQFZpZXdDaGlsZHJlbihIb3RUb2FzdENvbXBvbmVudCkgaG90VG9hc3RDb21wb25lbnRMaXN0OiBRdWVyeUxpc3Q8SG90VG9hc3RDb21wb25lbnQ+O1xuXG4gIHRvYXN0czogVG9hc3RbXSA9IFtdO1xuICB0b2FzdFJlZnM6IENyZWF0ZUhvdFRvYXN0UmVmW10gPSBbXTtcblxuICAvKiogU3ViamVjdCBmb3Igbm90aWZ5aW5nIHRoZSB1c2VyIHRoYXQgdGhlIHRvYXN0IGhhcyBiZWVuIGNsb3NlZC4gKi9cbiAgcHJpdmF0ZSBfb25DbG9zZWQgPSBuZXcgU3ViamVjdDxIb3RUb2FzdENsb3NlPigpO1xuXG4gIHByaXZhdGUgb25DbG9zZWQkID0gdGhpcy5fb25DbG9zZWQuYXNPYnNlcnZhYmxlKCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7fVxuXG4gIHRyYWNrQnlJZChpbmRleDogbnVtYmVyLCB0b2FzdDogVG9hc3QpIHtcbiAgICByZXR1cm4gdG9hc3QuaWQ7XG4gIH1cblxuICBjYWxjdWxhdGVPZmZzZXQodG9hc3RJZDogc3RyaW5nLCBwb3NpdGlvbjogVG9hc3RQb3NpdGlvbikge1xuICAgIGNvbnN0IHZpc2libGVUb2FzdHMgPSB0aGlzLnRvYXN0cy5maWx0ZXIoKHQpID0+IHQudmlzaWJsZSAmJiB0LnBvc2l0aW9uID09PSBwb3NpdGlvbik7XG4gICAgY29uc3QgaW5kZXggPSB2aXNpYmxlVG9hc3RzLmZpbmRJbmRleCgodG9hc3QpID0+IHRvYXN0LmlkID09PSB0b2FzdElkKTtcbiAgICBjb25zdCBvZmZzZXQgPVxuICAgICAgaW5kZXggIT09IC0xXG4gICAgICAgID8gdmlzaWJsZVRvYXN0c1xuICAgICAgICAgICAgLnNsaWNlKC4uLih0aGlzLmRlZmF1bHRDb25maWcucmV2ZXJzZU9yZGVyID8gW2luZGV4ICsgMV0gOiBbMCwgaW5kZXhdKSlcbiAgICAgICAgICAgIC5yZWR1Y2UoKGFjYywgdCkgPT4gYWNjICsgKHQuaGVpZ2h0IHx8IDApICsgSE9UX1RPQVNUX01BUkdJTiwgMClcbiAgICAgICAgOiAwO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH1cblxuICB1cGRhdGVIZWlnaHQoaGVpZ2h0OiBudW1iZXIsIHRvYXN0OiBUb2FzdCkge1xuICAgIHRvYXN0LmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gIH1cblxuICBhZGRUb2FzdChyZWY6IEhvdFRvYXN0UmVmKTogQWRkVG9hc3RSZWYge1xuICAgIHRoaXMudG9hc3RSZWZzLnB1c2gocmVmKTtcblxuICAgIGNvbnN0IHRvYXN0ID0gcmVmLmdldFRvYXN0KCk7XG5cbiAgICB0aGlzLnRvYXN0cy5wdXNoKHJlZi5nZXRUb2FzdCgpKTtcblxuICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcblxuICAgIHJldHVybiB7XG4gICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2VUb2FzdCh0b2FzdC5pZCk7XG4gICAgICB9LFxuICAgICAgdXBkYXRlTWVzc2FnZTogKG1lc3NhZ2U6IENvbnRlbnQpID0+IHtcbiAgICAgICAgdG9hc3QubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGVUb2FzdDogKG9wdGlvbnM6IFVwZGF0ZVRvYXN0T3B0aW9ucykgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVRvYXN0cyh0b2FzdCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgIH0sXG4gICAgICBhZnRlckNsb3NlZDogdGhpcy5nZXRBZnRlckNsb3NlZCh0b2FzdCksXG4gICAgfTtcbiAgfVxuXG4gIGNsb3NlVG9hc3QoaWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGNvbXAgPSB0aGlzLmhvdFRvYXN0Q29tcG9uZW50TGlzdC5maW5kKChpdGVtKSA9PiBpdGVtLnRvYXN0LmlkID09PSBpZCk7XG4gICAgaWYgKGNvbXApIHtcbiAgICAgIGNvbXAuY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICBiZWZvcmVDbG9zZWQodG9hc3Q6IFRvYXN0KSB7XG4gICAgdG9hc3QudmlzaWJsZSA9IGZhbHNlO1xuICB9XG5cbiAgYWZ0ZXJDbG9zZWQoY2xvc2VUb2FzdDogSG90VG9hc3RDbG9zZSkge1xuICAgIGNvbnN0IHRvYXN0SW5kZXggPSB0aGlzLnRvYXN0cy5maW5kSW5kZXgoKHQpID0+IHQuaWQgPT09IGNsb3NlVG9hc3QuaWQpO1xuICAgIGlmICh0b2FzdEluZGV4ID4gLTEpIHtcbiAgICAgIHRoaXMuX29uQ2xvc2VkLm5leHQoY2xvc2VUb2FzdCk7XG4gICAgICB0aGlzLnRvYXN0cyA9IHRoaXMudG9hc3RzLmZpbHRlcigodCkgPT4gdC5pZCAhPT0gY2xvc2VUb2FzdC5pZCk7XG4gICAgICB0aGlzLnRvYXN0UmVmcyA9IHRoaXMudG9hc3RSZWZzLmZpbHRlcigodCkgPT4gdC5nZXRUb2FzdCgpLmlkICE9PSBjbG9zZVRvYXN0LmlkKTtcbiAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG4gIH1cblxuICBoYXNUb2FzdChpZDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMudG9hc3RzLmZpbmRJbmRleCgodCkgPT4gdC5pZCA9PT0gaWQpID4gLTE7XG4gIH1cblxuICBwcml2YXRlIGdldEFmdGVyQ2xvc2VkKHRvYXN0OiBUb2FzdCkge1xuICAgIHJldHVybiB0aGlzLm9uQ2xvc2VkJC5waXBlKGZpbHRlcigodikgPT4gdi5pZCA9PT0gdG9hc3QuaWQpKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlVG9hc3RzKHRvYXN0OiBUb2FzdCwgb3B0aW9ucz86IFVwZGF0ZVRvYXN0T3B0aW9ucykge1xuICAgIHRoaXMudG9hc3RzID0gdGhpcy50b2FzdHMubWFwKCh0KSA9PiAoeyAuLi50LCAuLi4odC5pZCA9PT0gdG9hc3QuaWQgJiYgeyAuLi50b2FzdCwgLi4ub3B0aW9ucyB9KSB9KSk7XG4gIH1cbn1cbiJdfQ==